<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TetraBlock</title>
<style>
:root {
  /* D√©finition des variables CSS pour les couleurs primaires, secondaires, en surbrillance et le padding des boutons */
  --primary-color: #00008B80;
  --secondary-color: #fff;
  --highlight-color: #ADD8E680;
  --button-padding: 1em 2em;
}

* {
  /* R√©initialisation des marges */
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  transition: all 0.3s ease;
}

body {
  width: 100%;
  height: 100vh;
  background: linear-gradient(to right,#16191a , #242424, #16191a); ¬†¬†
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 16px;
} 

#menu {
  /* Le menu est un conteneur flex, centr√©, de hauteur compl√®te avec une couleur d'arri√®re-plan primaire et une couleur de texte secondaire */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background-color: var(--primary-color);
  color: var(--secondary-color);
}

#menu h1 {
  /* Sp√©cifie la taille de la police du titre dans le menu et la marge en dessous */
  font-size: 2em;
  margin-bottom: 1em;
}

#menu button {
  /* D√©finit le style des boutons dans le menu */
  background-color: var(--secondary-color);
  color: var(--primary-color);
  border: none;
  padding: var(--button-padding);
  margin: 0.5em 0;
  cursor: pointer;
  padding: 0.5em 1em;
}

@media screen and (max-width: 768px) {
  /* Ajuste la taille de la police du titre et le padding du bouton dans le menu pour les √©crans de moins de 768px */
  #menu h1 {
    font-size: 1.5em;
  }

}

@media screen and (max-width: 480px) {
  /* Ajuste la taille de l'arri√®re-plan pour les √©crans de moins de 480px */
  body {
    background-size: 50% 50%;
  }
}
#instructions-container {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #fff;
  color: #000;
  padding: 20px;
  border-radius: 15px;
  display: none; 
  justify-content: center;
  align-items: center;
}
#score-container {
  display: none;
}

#game {
  /* D√©finit le style de l'√©l√©ment #game avec un fond de couleur primaire et une bordure de couleur secondaire */
  background: var(--primary-color);
  border: 1px solid var(--secondary-color);
  margin: auto;
  display: block;
}

#game-container {
  /* Style du conteneur du jeu lorsqu'il n'est pas d√©marr√© */
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: var(--highlight-color);
  display: none;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  margin: auto;
}

#game-container.game-started {
  /* Style du conteneur du jeu lorsqu'il est d√©marr√© */
  display: flex;
}

#game-canvas {
  /* Le canvas du jeu est cach√© par d√©faut */
  display: none;
    background-color: rgb(13, 13, 15);
}
#gameOptions {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 300px;
    margin: 0 auto;
    background-color: var(--primary-color); /* Ajoute une couleur d'arri√®re-plan √† la bo√Æte */
    border-radius: 10px; /* Arrondit les coins de la bo√Æte */
    padding: 20px; /* Ajoute de l'espace autour du contenu de la bo√Æte */
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5); /* Ajoute une ombre √† la bo√Æte pour la faire ressortir */
}
.option {
    margin-bottom: 20px;
    font-size: 1.2em; /* Augmente la taille de la police pour une meilleure lisibilit√© */
}
.option label {
    margin-right: 10px;
    color: var(--secondary-color); /* Change la couleur du texte pour contraster avec l'arri√®re-plan */
}
.option select, .option input[type="checkbox"] {
    font-size: 1em; /* Augmente la taille de la police pour une meilleure lisibilit√© */
    padding: 5px; /* Ajoute de l'espace autour du texte dans le champ de s√©lection */
}
#options-container {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #fff;
  color: #000;
  padding: 20px;
  border-radius: 15px;
  display: none; 
  justify-content: center;
  align-items: center;
}

#controls {
  /* Style des contr√¥les du jeu, situ√©s au bas de la page */
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  justify-content: space-around;
  width: 100%;
}

#score {
  /* Style de l'affichage du score, positionn√© en haut √† gauche */
  position: absolute;
  top: 50px;
  left: 25%;
  transform: translateX(-50%);
  color: var(--secondary-color);
  font-size: 24px;
  font-weight: bold;
  padding: 20px;
}

#title {
  /* Style de l'affichage du titre, positionn√© en haut au centre */
  position: absolute;
  top: 0;
  left: 20%;
  transform: translateX(-50%);
  color: var(--primary-color);
  font-size: 15px;
  font-weight: bold;
  padding: 20px 0;
}

@media (prefers-reduced-motion: reduce) {
  /* En cas de pr√©f√©rence pour des animations r√©duites (d√©fini par le syst√®me d'exploitation de l'utilisateur), toutes les transitions sont d√©sactiv√©es. */
  * {
    transition: none !important;
  }
}

@media screen and (min-width: 1080px) and (max-height: 2408px) {
  /* Exemple de r√®gles sp√©cifiques pour cette r√©solution */
  body {
    background-color: #000;
  }

  #menu {
    padding: 10px;
  }

}
</style>

</head>
<body>
  <!-- Div contenant le menu avec des boutons pour d√©marrer le jeu, voir les instructions et voir les meilleurs scores -->
  <div id="menu">
    <h1>TetraBlock</h1>
    <button id="start-button" aria-label="Start game">Commencer le Jeu</button>
    <button id="instructions-button" aria-label="Instructions">Instructions</button>
    <button id="high-scores-button" aria-label="High scores">Meilleurs Scores</button>
	<button id="options-button" aria-label="Options">Options</button>
  </div>
<div id="instructions-container" style="display: hidden;">
  <h1 style="text-align: center; font-family: 'Lato', Courier, monospace;">Aide</h1>
  <p>
    <strong>Tetris :</strong> le jeu o√π les blocs tombent comme des feuilles d‚Äôautomne. Empilez-les pour remplir les lignes et les faire dispara√Ætre. Plus de lignes = plus de points. Si les blocs touchent le haut, c'est game over! üò±
    <br><br>
    <strong>Commandes :</strong>
    <ul>
      <li>Fl√®che gauche : bouge √† gauche.</li>
      <li>Fl√®che droite : bouge √† droite.</li>
      <li>Fl√®che vers le bas : chute rapide.</li>
      <li>Fl√®che vers le haut : rotation du bloc.</li>
    </ul>
    <strong>Astuce :</strong> Gardez les blocs en bas pour plus de chances de gagner. Et surtout, amusez-vous bien! üòä
  </p>
    <button id="close-instructions-button">Fermer les instructions</button>
  </div>
  
<div id="score-container" class="hidden">
  <h1>Score</h1>
  <p id="score">0</p>
  <button id="close-score-button">Retour</button>
</div>
<div id="options-container" style="display: none;">
    <h1>Options</h1>

    <div class="gameOptions">
        <label for="grid">Grille:</label>
        <select id="grid" name="grid">
            <option value="none">Aucune</option>
            <option value="standard">Standard</option>
            <option value="partial">Partielle</option>
            <option value="vertical">Verticale</option>
            <option value="full">Pleine</option>
        </select>
    </div>

    <div class="option">
        <label for="ghost">Fant√¥me:</label>
        <input type="checkbox" id="ghost" name="ghost" checked>
    </div>

    <button id="close-options-button">Retour</button>
</div>

  <!-- Div contenant le conteneur de jeu qui comprend un canvas pour le jeu, un titre et des contr√¥les pour d√©placer et tourner les blocs -->
  <div id="game-container">
    <canvas id="game-canvas" width="320" height="640"></canvas>
    <h1 id="title">BlockMaster</h1>

    <div id="controls">
      <button id="deplacer-gauche">D√©placer √† gauche</button>
      <button id="deplacer-droite">D√©placer √† droite</button>
      <button id="tourner-gauche">Tourner √† gauche</button>
      <button id="tourner-droite">Tourner √† droite</button>
    </div>
  </div>

</body>

<script>
"use strict";
/*jshint esversion: 6 */

// Initialisation des variables score et lines √† 0
let score = 0;
let lines = 0;

// Fonction qui g√©n√®re un nombre al√©atoire entre un minimum et un maximum inclus
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}


// Fonction qui g√©n√®re une s√©quence de noms de t√©traminos (formes des blocs du jeu Tetris)
function generateSequence() {
  const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z']; // Tous les types de t√©traminos

  while (sequence.length) {
    const rand = getRandomInt(0, sequence.length - 1); // On g√©n√®re un index al√©atoire
    const name = sequence.splice(rand, 1)[0]; // On retire le t√©tramino √† cet index de la s√©quence et on le r√©cup√®re
    tetrominoSequence.push(name); // On ajoute ce t√©tramino √† la s√©quence de t√©traminos
  }
}

// Fonction qui retourne le prochain t√©tramino √† afficher sur le terrain de jeu
function getNextTetromino() {
  if (tetrominoSequence.length === 0) {
    generateSequence(); // Si la s√©quence est vide, on en g√©n√®re une nouvelle
  }

  const name = tetrominoSequence.pop(); // On retire le prochain t√©tramino de la s√©quence
  const matrix = tetrominos[name]; // On r√©cup√®re la matrice du t√©tramino correspondant

  // On calcule la position initiale du t√©tramino sur le terrain de jeu
  const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);
  const row = name === 'I' ? -1 : -2;

  return {
    name: name,    // Nom du t√©tramino
    matrix: matrix, // Matrice du t√©tramino
    row: row,  // Position en ligne du t√©tramino
    col: col  // Position en colonne du t√©tramino
  };
}

// Fonction qui fait pivoter une matrice (utilis√©e pour la rotation des t√©traminos)
function rotate(matrix) {
  const N = matrix.length - 1;
  const result = Array.from({ length: N + 1 }, () => Array(N + 1).fill(0));

  for(let i = 0; i <= N; i++) {
    for(let j = 0; j <= N; j++) {
      result[j][N - i] = matrix[i][j]; // On remplit la nouvelle matrice en pivotant celle d'origine
    }
  }

  return result;
}

// Fonction pour v√©rifier si une cellule donn√©e est √† l'int√©rieur du terrain de jeu
function isInsidePlayfield(cellCol, cellRow, matrixRowLength, matrixColLength) {
  // Si la cellule est en dehors du terrain de jeu, on retourne false
  return !(cellCol < 0 || cellCol >= matrixColLength || cellRow >= matrixRowLength);
}

// Fonction pour v√©rifier si une cellule donn√©e est vide
function isCellEmpty(cellRow, cellCol) {
  // Si la cellule est vide, on retourne true
  return !playfield[cellRow][cellCol];
}

// Fonction pour v√©rifier si le mouvement d'un tetramino est valide
function isValidMove(matrix, cellRow, cellCol) {
  for (let row = 0; row < matrix.length; row++) {
    for (let col = 0; col < matrix[row].length; col++) {
      if (matrix[row][col]) {
        // Si la cellule n'est pas dans le terrain de jeu ou si elle n'est pas vide, le mouvement n'est pas valide
        if (!isInsidePlayfield(cellCol + col, cellRow + row, playfield.length, playfield[0].length) || !isCellEmpty(cellRow + row, cellCol + col)) {
          return false;
        }
      }
    }
  }
  // Si toutes les cellules sont valides, le mouvement est valide
  return true;
}

// Fonction pour placer un t√©tramino sur le terrain de jeu
function placeTetromino() {
  for (let row = 0; row < tetromino.matrix.length; row++) {
    for (let col = 0; col < tetromino.matrix[row].length; col++) {
      if (tetromino.matrix[row][col]) {
        // Si le t√©tramino d√©passe le haut du terrain de jeu, la partie est termin√©e
        if (tetromino.row + row < 0) {
          return showGameOver();
        }
        // On place le t√©tramino sur le terrain de jeu
        playfield[tetromino.row + row][tetromino.col + col] = tetromino.name;
      }
    }
  }

  // On v√©rifie si une ligne est compl√®te
  for (let row = playfield.length - 1; row >= 0; ) {
    if (playfield[row].every(cell => !!cell)) {
      // Si une ligne est compl√®te, on augmente le score et on d√©place toutes les lignes du dessus vers le bas
      score++;
	  lines++;
      for (let r = row; r >= 0; r--) {
        for (let c = 0; c < playfield[r].length; c++) {
          playfield[r][c] = playfield[r-1][c];
        }
      }
    }
    else {
      // Si la ligne n'est pas compl√®te, on passe √† la ligne suivante
      row--;
    }
  }

// On r√©cup√®re le prochain t√©tramino
tetromino = getNextTetromino();
}

// Fonction pour afficher le message de fin de partie
function showGameOver() {
  // On arr√™te l'animation
  cancelAnimationFrame(rAF);
  gameOver = true;

  // On pr√©pare le message de fin de partie
  context.fillStyle = 'black';
  context.globalAlpha = 0.75;
  context.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
  context.globalAlpha = 1;
  context.fillStyle = 'white';
  context.font = '36px monospace';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2);
}

// On r√©cup√®re le canvas et son contexte
const canvas = document.getElementById('game-canvas');
const context = canvas.getContext('2d');

// On d√©finit la taille des cases et on pr√©pare le terrain de jeu et la s√©quence de t√©traminos
const grid = 32;
const tetrominoSequence = [];
const playfield = [];

// On pr√©pare le terrain de jeu
for (let row = -2; row < 20; row++) {
  playfield[row] = [];
  for (let col = 0; col < 10; col++) {
    playfield[row][col] = 0;
  }
}

// On d√©finit les diff√©rentes formes de t√©traminos
const tetrominoShapes = {
  'I': '0/1111/0/0',
  'J': '100/111/0',
  'L': '001/111/0',
  'O': '11/11',
  'S': '011/110/0',
  'Z': '110/011/0',
  'T': '010/111/0'
};

function createMatrix(shape) {
  return shape.split('/').map(row => [...row].map(Number));
}

const tetrominos = Object.fromEntries(
  Object.entries(tetrominoShapes).map(([name, shape]) => [name, createMatrix(shape)])
);
// On d√©finit les couleurs des diff√©rents t√©traminos
const colors = {
  'I': 'cyan',
  'O': 'yellow',
  'T': 'purple',
  'S': 'green',
  'Z': 'red',
  'J': 'blue',
  'L': 'orange'
};

// On initialise quelques variables
let count = 0;
let tetromino = getNextTetromino();
let rAF = null;
let gameOver = false;

// Fonction principale du jeu, ex√©cut√©e en boucle
function loop() {
  // On demande la prochaine image d'animation
  rAF = requestAnimationFrame(loop);

  // On efface le canvas
  context.clearRect(0, 0, canvas.width, canvas.height);

  // On dessine la grille
  context.strokeStyle = 'white';
  for (let x = 0; x < canvas.width; x += grid) {
    context.beginPath();
    context.moveTo(x, 0);
    context.lineTo(x, canvas.height);
    context.stroke();
  }
  
  for (let y = 0; y < canvas.height; y += grid) {
    context.beginPath();
    context.moveTo(0, y);
    context.lineTo(canvas.width, y);
    context.stroke();
  }

  // On affiche le score et les lignes compl√©t√©es
  context.fillStyle = 'black';  
  context.font = '12px "Press Start 2P"';
  context.textAlign = 'right'; 
  context.fillText('Score: ' + score, canvas.width - 10, 20);
  context.fillText('Lignes: ' + lines, canvas.width - 10, 40);

  // On dessine les t√©traminos d√©j√† plac√©s sur le terrain de jeu
  for (let row = 0; row < 20; row++) {
    for (let col = 0; col < 10; col++) {
      if (playfield[row][col]) {
        const name = playfield[row][col];
        context.fillStyle = colors[name];
        context.fillRect(col * grid, row * grid, grid - 1, grid - 1);
      }
    }
  }

  // On dessine le t√©tramino qui est actuellement en train de tomber
  if (tetromino) {
    if (++count > (35 - Math.floor(score / 10))) {
      tetromino.row++;
      count = 0;

      if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
        tetromino.row--;
        placeTetromino();
      }
    }

    context.fillStyle = colors[tetromino.name];

    for (let row = 0; row < tetromino.matrix.length; row++) {
      for (let col = 0; col < tetromino.matrix[row].length; col++) {
        if (tetromino.matrix[row][col]) {
          context.fillRect((tetromino.col + col) * grid, (tetromino.row + row) * grid, grid - 1, grid - 1);
        }
      }
    }
  }
}
// √âv√©nements de clavier
  document.addEventListener('keydown', function(e) {
  if (gameOver) return;

  // Gauche et droite
  if (e.which === 37 || e.which === 39) {
    const col = e.which === 37 ?
        tetromino.col - 1
      : tetromino.col + 1;

    if (isValidMove(tetromino.matrix, tetromino.row, col)) {
      tetromino.col = col;
    }
  }

  // Haut (rotation)
  if (e.which === 38) {
    const matrix = rotate(tetromino.matrix);
    if (isValidMove(matrix, tetromino.row, tetromino.col)) {
      tetromino.matrix = matrix;
    }
  }

  // Bas (acc√©l√®re la descente)
  if(e.which === 40) {
    const row = tetromino.row + 1;

    if (!isValidMove(tetromino.matrix, row, tetromino.col)) {
      tetromino.row = row - 1;

      placeTetromino();
      return;
    }

    tetromino.row = row;
  }
});

// √âv√©nements de boutons de contr√¥le
  document.getElementById('deplacer-gauche').addEventListener('click', function() {
  if (!gameOver && isValidMove(tetromino.matrix, tetromino.row, tetromino.col - 1)) {
    tetromino.col--;
  }
});

  document.getElementById('deplacer-droite').addEventListener('click', function() {
  if (!gameOver && isValidMove(tetromino.matrix, tetromino.row, tetromino.col + 1)) {
    tetromino.col++;
  }
});

  document.getElementById('tourner-gauche').addEventListener('click', function() {
  if (!gameOver) {
    const matrix = rotate(rotate(rotate(tetromino.matrix)));
    if (isValidMove(matrix, tetromino.row, tetromino.col)) {
      tetromino.matrix = matrix;
    }
  }
});

  document.getElementById('tourner-droite').addEventListener('click', function() {
  if (!gameOver) {
    const matrix = rotate(tetromino.matrix);
    if (isValidMove(matrix, tetromino.row, tetromino.col)) {
      tetromino.matrix = matrix;
    }
  }
});

  document.getElementById("grid").onchange = function() {
    // G√©rer le changement de grille
}

  document.getElementById("ghost").onchange = function() {
    // G√©rer le changement de l'option fant√¥me
}

// √âv√©nement du bouton de d√©marrage
  document.getElementById('start-button').addEventListener('click', function() {

  // On ajoute la classe pour indiquer que le jeu a commenc√©
  document.getElementById('game-container').classList.add('game-started');

  // On cache le menu et on affiche le jeu
  document.getElementById('menu').style.display = 'none';
  document.getElementById("game-canvas").style.display = "block";
  
  // On v√©rifie que le navigateur supporte requestAnimationFrame
  if (!window.requestAnimationFrame) {
    window.alert("D√©sol√©, votre navigateur ne supporte pas requestAnimationFrame.");
    return;
  }

  rAF = requestAnimationFrame(loop);
});

const menu = document.getElementById('menu');
const instructionsContainer = document.getElementById('instructions-container');
const scoreContainer = document.getElementById('score-container');
const optionsContainer = document.getElementById('options-container');
const scoreElement = document.getElementById('score');

function showElement(buttonId, targetContainer, targetClass) {
  document.getElementById(buttonId).addEventListener('click', function() {
    targetContainer.classList.add(targetClass);
    menu.style.display = 'none';
    targetContainer.style.display = 'block';
  });
}

function hideElement(buttonId, targetContainer, targetClass) {
  document.getElementById(buttonId).addEventListener('click', function() {
    targetContainer.classList.remove(targetClass);
    targetContainer.style.display = 'none';
    menu.style.display = 'flex';
  });
}

showElement('instructions-button', instructionsContainer, 'instructions-started');
hideElement('close-instructions-button', instructionsContainer, 'instructions-started');
showElement('high-scores-button', scoreContainer, 'score-started');
hideElement('close-score-button', scoreContainer, 'score-started');
showElement('options-button', optionsContainer, 'options-started');
hideElement('close-options-button', optionsContainer, 'options-started');

</script>
</body>
</html>
